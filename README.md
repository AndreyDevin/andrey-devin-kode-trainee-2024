# andrey-devin-kode-trainee-2024
Разбивка на задачи и оценка времени на их выполнение.

1. 
Создать новый Compose+Retrofit+Koin проект
Успешно собрать, получить Hello World
Оценочно 30 мин.
Фактически 20 мин.

2.
Написать API-модель (20 мин) и ретрофит-интерфейс (30 мин)
Итого оценочно 50 мин.
Фактически 50 мин.

3.
Написать DI:
Создать класс ViewModel (30 мин)
Создать Koin-модуль,
получить в  Activity инстанс ViewModel (30 мин)
В качестве теста, вывести на экран ответ API.
Итого оценочно 60 мин.
Фактически написал за 50 мин, но при попытке получить ответ API, поймал странную ошибку:
HTTP FAILED: java.net.SocketException: socket failed: EPERM (Operation not permitted)
Как понимаю, приложению просто не давался выход в интернет (разрешение в манифесте было).
Но я наверное час искал что сделал не так.
В итоге надо было просто удалить приложение с эмулятора))
Установил заново и всё заработало.
Так что фактически на пункт 3 ушло 120 мин.


4.
Написать методы Data-слоя:
- getApiData
- фильрация по департаменту
- фильтрация (поиск) по имени/никнейму
- сортировка по алфавиту
- сортировка по ДР
по 10 мин на метод,
плюс протестировать каждый метод - еще по 10 мин
Итого оценочно 100 мин.
Фактически 270 мин.
- Причина сильного расхождения оценочного и фактического - при сортировке по ДР,
- не хотел использовать ZonedDateTime или подобное,
- но посмотрев как это выглядит, переделывал поле birthday как ZonedDateTime.

Переходим к UI. Планирую реализовать MVI-подход.
5.
Написать sealed class Intent, где соберем возможные варианты
действий пользователя:
- начальное состояние "с дефолтными настройками"
- выбор департамента
- поиск по имени/никнэйму
- сортировка по алфавиту/ДР
- открыть детали о конкретной персоне
- принудительная перезагрузка (по свайпу пользователя)
Оценочно 60 мин.
Фактически 180 мин :)
- Причина сильного расхождения оценочного и фактического - пробовал варианты, как лучше сделать.

6.
Написать sealed class UiState, где соберем возможные варианты данных для отображения:
- список отсортированный по алфавиту
- список отсортированный по ДР
- конкретная персона
- не найдено ни одного пользователя соответствующего символам в поисковой строке
- нет данных (Loading)
- нет данных (Error)
Оценочно 30 мин, подписаться на это в Activity + 20 мин.
Фактически 200 мин :(
- Причина сильного расхождения оценочного и фактического - пробовал варианты, как лучше сделать,
- и в итоге переписал всю вьюмодель.

6.1
По факту, прежде чем переходить к пункту 7, опять изменил UiState.
Сделал, что это не только sealed class состояния данных, но и содержит в себе data class с выбором,
который сделал пользователь: департамент, текст в поисковой строке, тип сортировки.
Таким образом, при смене конфигурации устройства, всегда можно было восстановить состояние UI.
Это, вместе с данными от API, содержится в одном объекте по принципу единого источника данных.
Заняло 80 мин.

7.
Написать composable PersonDetails (50 мин)
Реализовть BackPressed (20 мин)
Итого оценочно 70 мин.
Фактически 200 мин :|

8.
Написать composable PersonsListItem (35 мин)
и composable PersonsLazyColumn (35 мин)
Итого оценочно 70 мин.
Фактически 180 мин...

8.1
По факту, прежде чем переходить к пункту 9, поменял реализацию BackPressed из экрана деталей,
чтобы возвращаться на список с сохраненной позицией скролинга.
для этого UiState.userChoice теперь имеет поле val lazyListState: LazyListState
Заняло 50 мин.

9.
Написать и потестить ScrollableTabRow со списком департаментов
Оценочно 60 мин.
Фактически 90 мин.

10.
Написать и потестить BottomSheet с вариантами фильтрации по алфавиту/по ДР
Оценочно 50 мин.
Фактически:
170 мин непосредственно на BottomSheet
и 180 мин на разделитель списка, на тех, у кого ДР будет в этом году и в следующем.
Так долго потратил на разделитель, потому что сначала местоположение разделителя считал в UseCase
(не хотел нагружать UI дополнительными расчетами).
Но потом решил, что это нарушает принципы clean, что доменный слой знает о маленьком элементе дизайна.
Переделал на вариант где EmployeesList сама находит dividerIndex.

11.
Написать и потестить SearchField (поиск по имени/никнэйму).
Реализовать при этом вариант "ничего не найдено".
Оценочно 90 мин.
Фактически 140 мин.

12.
Реализовать Pull-to-refresh
Оценочно 60 мин.
Фактически 80 мин.

13.
Отображение статуса загрузки данных (задача со звездочкой)
и потестить, как работает.
Оценочно 80 мин.
Фактически 450 мин (7ч 30м) - реально оказалась "под звездочкой",
переписал ViewModel и доменный слой :)



Всего:
оценочно 830 мин (13ч 50м)
фактически 2460 мин (41ч 00м)

P.S.
Уже после дедлайна, позволю себе постскриптум о своём виденее, что в итоге получилось.
Изначально мною был выбран паттерн MVI, который, на мой взгляд,
хорошо ложится на single activity + compose.
Из дизайна в сторону ViewModel направлен только один оъект - Intent.
И подписан дизайн только на обновление одного объекта - UiState.
Получается легко контролировать перекомпозиции composable-слоя.
Со стороны разработчика читается и поддерживается такая структура, на мой взгляд, также не плохо.

Отдельно хочется коснуться "задачи со звездочкой".
На первый взгляд показалась ничего особенного - отловить и вывести ошибку.
Но довольно трудно получилось реализовать это в плане дальнейшего поведения.
Программа же должна не просто вывести ошибку, но и сохранить функциональность,
не потерять существующее состояние.
Тем более этот момент никак не описан в т.з. - экран с ошибкой, Ok, а что дальше?
Пришлось действовать на своё усмотрение.
Реализовал такое поведение:
если в процессе работы мы получили некое успешное состояние - список сотрудников или окно деталей,
то это состояние каждый раз сохраняется, так сказать, на всякий случай...
Это 29 строка во ViewModel - private lateinit var savedState: UiState,
если при попытке обновится из доменного слоя пришла ошибка,
то программа 3 секунды показывает текст ошибки (в это время кликлистнеры заблокированны),
а затем возвращается к поледнему успешному состоянию.
Так как в т.з. указан пример ошибочного запроса в сеть,
но не описано каким конкретно элементом управления вызывать этот ошибочный запрос,
я для этой цели в правом нижнем углу экрана сделал Checkbox.

Ну и конечно бросается разница между оценочным и фактическим временем затраченным на написание программы.
Сказывается всё таки мой малый опыт - виденее что нужно сделать есть,
а начинаешь непосредственно реализовывать, возникает куча вопросов и нюансов.
Да это и в любой области так и отличает любителя от профессионала ;)

И по итогу, сейчас я доволен тем что получилось,
осталось узнать, что профессионалы скажут по этому поводу... :)  


P.S.2
В этом коммите (после дедлайна) внёс изменения в код.
Понимаю, что не честно, но раз уж написал, - надо сохранить :)
1. Изменения в поведении программы, при работе в режиме с ошибками.
Дополнительно отделил Data.Loading и Data.Error, как реализации отдельного интерфейса Info, 
это по прежнему часть Data, но занимает отдельное поле в UiState.
Теперь не требуется сохранять успешные состояния и возвращаться.
Теперь Info эмитится отдельно, а новые данные отдельно, только в случае успеха,
в случае неудачи - не меняются.
Эта логика в fun stateCreate во вьюмодели.
2. Также изменения в MainActivity - убрал от туда лишний код в файл Entry.kt 
Получается - это единственный вход в composable-слой.